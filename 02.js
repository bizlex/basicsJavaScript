// 1. Объекты

// Объекты же используются для хранения коллекций различных значений и более сложных сущностей.
// Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. 
// Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), 
// а значение может быть чем угодно.

// Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"

// Литералы и свойства

// При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств 
// в виде пар «ключ: значение»:

// let user = {     // объект
//   name: "John",  // под ключом "name" хранится значение "John"
//   age: 30        // под ключом "age" хранится значение 30
// };
// У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). 
// После имени свойства следует двоеточие ":", и затем указывается значение свойства. 
// Если в объекте несколько свойств, то они перечисляются через запятую.

// В объекте user сейчас находятся два свойства:

// Первое свойство с именем "name" и значением "John".
// Второе свойство с именем "age" и значением 30.

// Значение может быть любого типа. Давайте добавим свойство с логическим значением:

// user.isAdmin = true;

// Для удаления свойства мы можем использовать оператор delete:

// delete user.age;

// Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

// let user = {
//   name: "John",
//   age: 30,
//   "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
// };

// !Объект, объявленный через const, может быть изменён.
// const user = {
//   name: "John"
// };

// user.name = "Pete"; // (*)
// alert(user.name); // Pete

// Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. 
// Дело в том, что объявление const защищает от изменений только саму переменную user, а не её содержимое.

// Квадратные скобки
// Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает

// Точка требует, чтобы ключ был именован по правилам именования переменных. 
// То есть не имел пробелов, не начинался с цифры и не содержал специальные символы, кроме $ и _.

// Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. 
// Такой способ сработает с любым именем свойства:

// let user = {};

// присваивание значения свойству
// user["likes birds"] = true;

// получение значения свойства
// alert(user["likes birds"]); // true

// удаление свойства
// delete user["likes birds"];

// Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. 
// Например, имя свойства может храниться в переменной:

// let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
// user[key] = true;
// Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода.

// Запись «через точку» такого не позволяет:

// let user = {
//   name: "John",
//   age: 30
// };

// let key = "name";
// alert( user.key ); // undefined

// Вычисляемые свойства
// Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

// Пример:

// let fruit = prompt("Какой фрукт купить?", "apple");

// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };

// alert( bag.apple ); // 5, если fruit="apple"
// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять из переменной fruit.

// И если посетитель введёт слово "apple", то в объекте bag теперь будет лежать свойство {apple: 5}.

// Квадратные скобки дают намного больше возможностей, чем запись через точку. 
// Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.

// Подведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку. 
// Если же нам нужно что-то более сложное, то мы используем квадратные скобки.

// Свойство из переменной

// function makeUser(name, age) {
//     return {
//       name: name,
//       age: age
      // ...другие свойства
//     };
// }

// let user = makeUser("John", 30);
// alert(user.name); // John

//   В примере выше название свойств name и age совпадают с названиями переменных, 
//   которые мы подставляем в качестве значений этих свойств. Такой подход настолько распространён, 
//   что существуют специальные короткие свойства для упрощения этой записи.
  
//   Вместо name:name мы можем написать просто name:
  
// function makeUser(name, age) {
//     return {
//         name, // то же самое, что и name: name
//         age   // то же самое, что и age: age
        // ...
//     };
// }
// let user = makeUser("John", 30);
// alert(user.name); // John
//   Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:
  
// let user = {
//     name,  // тоже самое, что и name:name
//     age: 30
// };

// Ограничения на имена свойств
// Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, 
// такими как «for», «let», «return» и т.д.

// Но для свойств объекта такого ограничения нет:

// эти имена свойств допустимы
// let obj = {
//   for: 1,
//   let: 2,
//   return: 3
// };

// alert( obj.for + obj.let + obj.return );  // 6
// Иными словами, нет никаких ограничений к именам свойств. 
// Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).

// Все другие типы данных будут автоматически преобразованы к строке.

// Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0":

// let obj = {
//   0: "Тест" // то же самое что и "0": "Тест"
// };

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
// alert( obj["0"] ); // Тест
// alert( obj[0] ); // Тест (то же свойство)

// Проверка существования свойства, оператор «in»

// В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. 
// Даже если свойства не существует – ошибки не будет!

// При обращении к свойству, которого нет, возвращается undefined. 
// Это позволяет просто проверить существование свойства:

// let user = {};

// alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
// Также существует специальный оператор "in" для проверки существования свойства в объекте.

// Синтаксис оператора:

// "key" in object
// Пример:

// let user = { name: "John", age: 30 };

// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует
// Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства.

// let user = { age: 30 };

// let key = "age";
// alert( key in user ); // true, имя свойства было взято из переменной key
// Для чего вообще нужен оператор in? Разве недостаточно сравнения с undefined?

// В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, 
// когда оно не подходит, и нужно использовать "in".

// Это когда свойство существует, но содержит значение undefined:

// let obj = {
//   test: undefined
// };

// alert( obj.test ); //  выведет undefined, значит свойство не существует?
// alert( "test" in obj ); // true, свойство существует!
// В примере выше свойство obj.test технически существует в объекте. Оператор in сработал правильно.

// Цикл «for…in»

// Для перебора всех свойств объекта используется цикл for..in. 
// Этот цикл отличается от изученного ранее цикла for(;;).

// Синтаксис:

// for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
// }
// К примеру, давайте выведем все свойства объекта user:

// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true
// };

// for (let key in user) {
  // ключи
//   alert( key );  // name, age, isAdmin
  // значения ключей
//   alert( user[key] ); // John, 30, true
// }
// Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, 
// как, например, let key здесь.

// Кроме того, мы могли бы использовать другое имя переменной. 
// Например, часто используется вариант "for (let prop in obj)".

//tasks
//1
// let user = {};
// user.name = 'John';
// user.surname = 'Smith';
// user.name = 'Pete';
// delete user.name;

//2
// function isEmpty(object) {
//     for (let key in object) {
//         return false;
//     }
//     return true;
// }

// let user = {name: 'a', age: 20};
// let user2 = {};
// console.log(isEmpty(user));
// console.log(isEmpty(user2));

//3
// yes

//4
// let salaries = {
//     John: 100,
//     Ann: 160,
//     Pete: 130
// }
// let sum = 0;
// for (let prop in salaries) {
//     sum += salaries[prop];
// }
// console.log('sum = ', sum);

//5
// let menu = {
//     width: 200,
//     height: 300,
//     title: "My menu"
// };

// function multiplyNumeric(obj) {
//     for (let key in obj) {
//         if (typeof(obj[key]) == 'number') {
//             obj[key] *= 2;
//         }
//     }
// }


// 2. Копирование объектов и ссылки

