// 1. Объекты

// Объекты же используются для хранения коллекций различных значений и более сложных сущностей.
// Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. 
// Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), 
// а значение может быть чем угодно.

// Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"

// Литералы и свойства

// При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств 
// в виде пар «ключ: значение»:

// let user = {     // объект
//   name: "John",  // под ключом "name" хранится значение "John"
//   age: 30        // под ключом "age" хранится значение 30
// };
// У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). 
// После имени свойства следует двоеточие ":", и затем указывается значение свойства. 
// Если в объекте несколько свойств, то они перечисляются через запятую.

// В объекте user сейчас находятся два свойства:

// Первое свойство с именем "name" и значением "John".
// Второе свойство с именем "age" и значением 30.

// Значение может быть любого типа. Давайте добавим свойство с логическим значением:

// user.isAdmin = true;

// Для удаления свойства мы можем использовать оператор delete:

// delete user.age;

// Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

// let user = {
//   name: "John",
//   age: 30,
//   "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
// };

// !Объект, объявленный через const, может быть изменён.
// const user = {
//   name: "John"
// };

// user.name = "Pete"; // (*)
// alert(user.name); // Pete

// Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. 
// Дело в том, что объявление const защищает от изменений только саму переменную user, а не её содержимое.

// Квадратные скобки
// Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает

// Точка требует, чтобы ключ был именован по правилам именования переменных. 
// То есть не имел пробелов, не начинался с цифры и не содержал специальные символы, кроме $ и _.

// Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. 
// Такой способ сработает с любым именем свойства:

// let user = {};

// присваивание значения свойству
// user["likes birds"] = true;

// получение значения свойства
// alert(user["likes birds"]); // true

// удаление свойства
// delete user["likes birds"];

// Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. 
// Например, имя свойства может храниться в переменной:

// let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
// user[key] = true;
// Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода.

// Запись «через точку» такого не позволяет:

// let user = {
//   name: "John",
//   age: 30
// };

// let key = "name";
// alert( user.key ); // undefined

// Вычисляемые свойства
// Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

// Пример:

// let fruit = prompt("Какой фрукт купить?", "apple");

// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };

// alert( bag.apple ); // 5, если fruit="apple"
// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять из переменной fruit.

// И если посетитель введёт слово "apple", то в объекте bag теперь будет лежать свойство {apple: 5}.

// Квадратные скобки дают намного больше возможностей, чем запись через точку. 
// Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода.

// Подведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку. 
// Если же нам нужно что-то более сложное, то мы используем квадратные скобки.

// Свойство из переменной

// function makeUser(name, age) {
//     return {
//       name: name,
//       age: age
      // ...другие свойства
//     };
// }

// let user = makeUser("John", 30);
// alert(user.name); // John

//   В примере выше название свойств name и age совпадают с названиями переменных, 
//   которые мы подставляем в качестве значений этих свойств. Такой подход настолько распространён, 
//   что существуют специальные короткие свойства для упрощения этой записи.
  
//   Вместо name:name мы можем написать просто name:
  
// function makeUser(name, age) {
//     return {
//         name, // то же самое, что и name: name
//         age   // то же самое, что и age: age
        // ...
//     };
// }
// let user = makeUser("John", 30);
// alert(user.name); // John
//   Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:
  
// let user = {
//     name,  // тоже самое, что и name:name
//     age: 30
// };

// Ограничения на имена свойств
// Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, 
// такими как «for», «let», «return» и т.д.

// Но для свойств объекта такого ограничения нет:

// эти имена свойств допустимы
// let obj = {
//   for: 1,
//   let: 2,
//   return: 3
// };

// alert( obj.for + obj.let + obj.return );  // 6
// Иными словами, нет никаких ограничений к именам свойств. 
// Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).

// Все другие типы данных будут автоматически преобразованы к строке.

// Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0":

// let obj = {
//   0: "Тест" // то же самое что и "0": "Тест"
// };

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
// alert( obj["0"] ); // Тест
// alert( obj[0] ); // Тест (то же свойство)

// Проверка существования свойства, оператор «in»

// В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. 
// Даже если свойства не существует – ошибки не будет!

// При обращении к свойству, которого нет, возвращается undefined. 
// Это позволяет просто проверить существование свойства:

// let user = {};

// alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
// Также существует специальный оператор "in" для проверки существования свойства в объекте.

// Синтаксис оператора:

// "key" in object
// Пример:

// let user = { name: "John", age: 30 };

// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует
// Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства.

// let user = { age: 30 };

// let key = "age";
// alert( key in user ); // true, имя свойства было взято из переменной key
// Для чего вообще нужен оператор in? Разве недостаточно сравнения с undefined?

// В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, 
// когда оно не подходит, и нужно использовать "in".

// Это когда свойство существует, но содержит значение undefined:

// let obj = {
//   test: undefined
// };

// alert( obj.test ); //  выведет undefined, значит свойство не существует?
// alert( "test" in obj ); // true, свойство существует!
// В примере выше свойство obj.test технически существует в объекте. Оператор in сработал правильно.

// Цикл «for…in»

// Для перебора всех свойств объекта используется цикл for..in. 
// Этот цикл отличается от изученного ранее цикла for(;;).

// Синтаксис:

// for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
// }
// К примеру, давайте выведем все свойства объекта user:

// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true
// };

// for (let key in user) {
  // ключи
//   alert( key );  // name, age, isAdmin
  // значения ключей
//   alert( user[key] ); // John, 30, true
// }
// Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, 
// как, например, let key здесь.

// Кроме того, мы могли бы использовать другое имя переменной. 
// Например, часто используется вариант "for (let prop in obj)".

//tasks
//1
// let user = {};
// user.name = 'John';
// user.surname = 'Smith';
// user.name = 'Pete';
// delete user.name;

//2
// function isEmpty(object) {
//     for (let key in object) {
//         return false;
//     }
//     return true;
// }

// let user = {name: 'a', age: 20};
// let user2 = {};
// console.log(isEmpty(user));
// console.log(isEmpty(user2));

//3
// yes

//4
// let salaries = {
//     John: 100,
//     Ann: 160,
//     Pete: 130
// }
// let sum = 0;
// for (let prop in salaries) {
//     sum += salaries[prop];
// }
// console.log('sum = ', sum);

//5
// let menu = {
//     width: 200,
//     height: 300,
//     title: "My menu"
// };

// function multiplyNumeric(obj) {
//     for (let key in obj) {
//         if (typeof(obj[key]) == 'number') {
//             obj[key] *= 2;
//         }
//     }
// }


// 2. Копирование объектов и ссылки

// Одним из фундаментальных отличий объектов от примитивных типов данных является то, 
// что они хранятся и копируются «по ссылке».

// Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

// let message = "Привет!";
// let phrase = message;
// В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".

// Объекты ведут себя иначе.
// !Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

// let user = {
//   name: "Иван"
// };

// Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.

// !Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

// Если мы представляем объект как ящик, то переменная – это ключ к нему. 
// Копирование переменной дублирует ключ, но не сам ящик.

// let user = { name: "Иван" };

// let admin = user; // копируется ссылка
// ?Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:

// Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:

// let user = { name: 'Иван' };
// let admin = user;
// admin.name = 'Петя'; // изменено по ссылке из переменной "admin"
// alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"

// Сравнение по ссылке

// Операторы равенства == и строгого равенства === для объектов работают одинаково.
// Два объекта равны только в том случае, если это один и тот же объект.

// В примере ниже две переменные ссылаются на один и тот же объект, поэтому они равны друг другу:

// let a = {};
// let b = a; // копирование по ссылке
// alert( a == b ); // true, т.к. обе переменные ссылаются на один и тот же объект
// alert( a === b ); // true

// В другом примере два разных объекта не равны, хотя оба пусты:

// let a = {};
// let b = {}; // два независимых объекта
// alert( a == b ); // false
// Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.

// Клонирование и объединение объектов, Object.assign

// Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

// Это выполнимо, но немного сложно, так как в JavaScript нет встроенного метода для этого. 
// На самом деле, такая нужда возникает редко. В большинстве случаев нам достаточно копирования по ссылке.
// Но если мы действительно этого хотим, то нам нужно создавать новый объект и 
// повторять структуру дублируемого объекта, перебирая его свойства и копируя их.

// let user = {
//   name: "Иван",
//   age: 30
// };

// let clone = {}; // новый пустой объект

// скопируем все свойства user в него
// for (let key in user) {
//   clone[key] = user[key];
// }

// теперь в переменной clone находится абсолютно независимый клон объекта
// clone.name = "Пётр"; // изменим в нём данные

// alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// Кроме того, для этих целей мы можем использовать метод Object.assign.

// Синтаксис:
// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
// Возвращает объект dest.

// let user = { name: "Иван" };

// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:

// let user = { name: "Иван" };

// Object.assign(user, { name: "Пётр" });

// alert(user.name); // теперь user = { name: "Пётр" }

// Мы также можем использовать Object.assign для замены for..in на простое клонирование:

// let user = {
//   name: "Иван",
//   age: 30
// };

// let clone = Object.assign({}, user);
// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.

// Вложенное клонирование
// До сих пор мы предполагали, что все свойства объекта user хранят примитивные значения. 
// Но свойства могут быть ссылками на другие объекты. Что с ними делать?

// let user = {
//   name: "Иван",
//   sizes: {
//     height: 182,
//     width: 50
//   }
// };

// alert( user.sizes.height ); // 182
// Теперь при клонировании недостаточно просто скопировать clone.sizes = user.sizes, поскольку user.sizes – это объект, 
// он будет скопирован по ссылке. А значит объекты clone и user в своих свойствах sizes будут 
// ссылаться на один и тот же объект

// Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение user[key] объектом, 
// и если это так – скопировать и его структуру тоже. Это называется «глубокое клонирование».

// Мы можем реализовать глубокое клонирование, используя рекурсию. 
// ?Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод _.cloneDeep(obj) 
// из JavaScript-библиотеки lodash.

