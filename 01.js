//1. Привет, мир!
// alert('Hello World2!') 

//2. Структура кода
// alert('Hello'); alert('friend')
// same
// alert('Hello') 
// alert('friend')
// alert(3+
// 1
// +2)
// [1,2].forEach(alert)
// alert("Error");
// [1, 2].forEach(alert)

//3. Строгий режим — "use strict"
//В начале скрипта писать "use strict", чтобы работали современные фичи языка
//Если используешь классы и модули -- строгий режим сам включается

//4. Переменные
// let message;
// message = 'Hello!';
// message = 'World!'; //change data
// alert(message);

// let hello = 'Hello World!';
// message = hello; // copy data
// alert(message);
// alert(hello);

// let 1a; //can't
// let $; //can
// let _; //can

// let apple;
// let Apple; //different variable

//tasks

//1
// let name = 'Джон';
// let admin;
// admin = name;
// alert(admin);

//2
// let planetEarth;
// let currentUser;

//3
//можно использовать заглавные буквы для константы const BIRTHDAY = '18.04.1982'; 
//(так как они известна до выполения кода). А для const AGE = someCode(BIRTHDAY); нет, так как код вычисляется

//5. Типы данных
// 8 basic data types
//«динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.
// Не будет ошибкой
// let message = "hello";
// message = 123456;

// 1 -- Number

// let n = 123;
// n = 12.345;
// Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
// alert( 1 / 0 ); // Infinity
// alert( Infinity ); // Infinity
// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции
// alert( "не число" / 2 ); // NaN, такое деление является ошибкой
// Если где-то в математическом выражении есть NaN, то результатом вычислений с его участием будет NaN.
// alert( "не число" / 2 + 5 ); // NaN

// 2 -- bigInt
//тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), 
//или меньше, чем -(253-1) для отрицательных чисел.

// символ "n" в конце означает, что это BigInt
// const bigInt = 1234567890123456789012345678901234567890n;

// 3 -- String

// Двойные кавычки: "Привет".
// Одинарные кавычки: 'Привет'.
// Обратные кавычки: `Привет`.

// 4 -- Boolean
// может принимать только два значения: true (истина) и false (ложь)

// 5 -- null
//Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
// let age = null; // значение переменной age неизвестно.

// 6 -- undefined
// означает, что «значение не было присвоено».
// let age;
// alert(age); // выведет "undefined"

// 7 -- object
// В объектах же хранят коллекции данных или более сложные структуры.

// 8 -- symbol
// используется для создания уникальных идентификаторов в объектах

// tasks

// 1
// let name = "Ilya";
// alert( `hello ${1}` ); // hello 1
// alert( `hello ${"name"}` ); // hello name
// alert( `hello ${name}` ); // hello Ilya  


//6. Взаимодействие: alert, prompt, confirm

// alert("Hello");
//показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».

//result = prompt(title, [default]);
// код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
// title Текст для отображения в окне.
// default лучше указывать хотя бы так ('') для EI
// Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.

// let title = 'Hi!'
// result = prompt(title, 'User');

//confirm
//result = confirm(question);
// Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
// Результат – true, если нажата кнопка OK. В других случаях – false.
// let result = confirm('How old are you?');

//Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать
// с остальной частью страницы до тех пор, пока окно не будет закрыто.

//tasks

//1
// let question = prompt('What is your name?', '');
// alert(`Answer: ${question}`);

//7. Преобразование типов

//Строковое преобразование
// Например, alert(value) преобразует значение к строке.
// Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке

// let value = true;
// alert(typeof value); // boolean
// value = String(value); // теперь value это строка "true"
// alert(typeof value); // string

// Численное преобразование
// alert( "6" / "2" ); // 3, строки преобразуются в числа

// Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу
// let str = "123";
// alert(typeof str); // string
// let num = Number(str); // становится числом 123
// alert(typeof num); // number

// Правила численного преобразования:
// undefined	    NaN
// null	            0
// true / false	    1 / 0
// string	        Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, 
//                  иначе из непустой строки «считывается» число. При ошибке результат NaN.

// Логическое преобразование
// Правило преобразования:
// 0, null, undefined, NaN, ""	    false
// любое другое значение	        true

// alert( Boolean(1) ); // true
// alert( Boolean(0) ); // false

// alert( Boolean("Привет!") ); // true
// alert( Boolean("") ); // false

// alert( Boolean("0") ); // true
// alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)

//8. Базовые операторы, математика
// Операнд – то, к чему применяется оператор. 
// Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2
// Унарным называется оператор, который применяется к одному операнду.
// x = -x
// Бинарным называется оператор, который применяется к двум операндам
// x = b - a

// Результат a % b – это остаток от целочисленного деления a на b.
// В выражении a ** b оператор возведения в степень умножает a на само себя b раз.
// квадратный корень является возведением в степень 1/2:
// alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)

// Сложение и преобразование строк — это особенность бинарного плюса +. 
// Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.

// alert( 6 - '2' ); // 4, '2' приводится к числу
// alert( '6' / '2' ); // 3, оба операнда приводятся к числам

// Не влияет на числа
// let x = 1;
// alert( +x ); // 1

// let y = -2;
// alert( +y ); // -2

// Преобразует не числа в числа
// laert( +true ); // 1
// alert( +"" );   // 0
// На самом деле это то же самое, что и Number(...), только короче.

// let apples = "2";
// let oranges = "3";

// оба операнда предварительно преобразованы в числа
// alert( +apples + +oranges ); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5

// оператор присваивания может возвращать значение
// let a = 1;
// let b = 2;
// let c = 3 - (a = b + 1); // c = 0

// Инкремент/декремент можно применить только к переменной. 
// Попытка использовать его на значении, типа 5++, приведёт к ошибке.

// let counter = 1;
// let a = counter++;

// alert(a); // 1
// alert(counter); // 2

// let counter = 1;
// let a = ++counter;

// alert(a); // 2
// alert(counter); // 2

// Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,.
// let a = (1 + 2, 3 + 4);
// alert( a ); // 7 (результат вычисления 3 + 4)
// Первое выражение 1 + 2 выполняется, а результат отбрасывается. 
// Затем идёт 3 + 4, выражение выполняется и возвращается результат.
// оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере.

//tasks

//1
// let a = 1, b = 1;
// let c = ++a; // a = 2, c = 2
// let d = b++; // b = 2, d = 1

//2
// let a = 2;
// let x = 1 + (a *= 2); // a = 4, x = 5 

//3 
// "" + 1 + 0 // 10
// "" - 1 + 0 // -1
// true + false // 1
// 6 / "3" // 2
// "2" * "3" // 6
// 4 + 5 + "px" // 45px
// "$" + 4 + 5 // $45
// "4" - 2 // 2
// "4px" - 2 // NaN
// 7 / 0 // Infinity (у меня было NaN)
// "  -9  " + 5 //   -9  5
// "  -9  " - 5 // -14
// null + 1 // 1
// undefined + 1 // NaN
// " \t \n" - 2 // -2  \n - перенос строки \t - табуляция

//4
// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);

// alert(+a + +b); // 12


// 9. Операторы сравнения

// cтроки сравниваются посимвольно
// При сравнении значений разных типов JavaScript приводит каждое из них к числу.
// alert( '2' > 1 ); // true, строка '2' становится числом 2
// alert( '01' == 1 ); // true, строка '01' становится числом 1

// Строгое сравнение
// Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:
// alert( 0 == false ); // true
// Это происходит из-за того, что операнды разных типов преобразуются оператором == к числу. 
// В итоге, и пустая строка, и false становятся нулём.

// !Оператор строгого равенства === проверяет равенство без приведения типов.

// Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования.
// alert( 0 === false ); // false, так как сравниваются разные типы

// Сравнение с null и undefined
// ?При строгом равенстве ===
// Эти значения различны, так как различны их типы.
// alert( null === undefined ); // false

// ?При нестрогом равенстве ==
// !Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
// alert( null == undefined ); // true

// При использовании математических операторов и других операторов сравнения < > <= >=
// Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

// alert( null > 0 );  // (1) false
// alert( null == 0 ); // (2) false
// alert( null >= 0 ); // (3) true
// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. 
// Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно.
// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: 
// эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. 
// Поэтому (2) null == 0 ложно.

// !Значение undefined несравнимо с другими значениями:
// alert( undefined > 0 ); // false (1)
// alert( undefined < 0 ); // false (2)
// alert( undefined == 0 ); // false (3)
// Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, 
// а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
// Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.

//!Относитесь очень осторожно к любому сравнению с undefined/null, кроме случаев строгого равенства ===.

// !Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null/undefined, 
// разве что вы полностью уверены в том, что делаете. 

// !Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

//tasks

//1
// 5 > 4  // true
// "ананас" > "яблоко" // false
// "2" > "12" // true because посимвольное сравнение (was false)
// undefined == null // true
// undefined === null // false
// null == "\n0\n" // false
// null === +"\n0\n" // false


// 10. Условное ветвление: if, '?'

// Для выполнения различных действий мы можем использовать инструкцию if и условный оператор ?, 
// который также называют оператором «вопросительный знак».

// Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.
// Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
// Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).

// Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.

// Условный оператор „?“. 
// Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.
// let result = условие ? значение1 : значение2;
// Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.

// Иногда оператор «вопросительный знак» ? используется в качестве замены if:
// let company = prompt('Какая компания создала JavaScript?', '');
// (company == 'Netscape') ?
//    alert('Верно!') : alert('Неправильно.');
// Не рекомендуется использовать оператор вопросительного знака таким образом.
// Несмотря на то, что такая запись короче, чем эквивалентная инструкция if, она менее читабельна.

//tasks

//1
// if ("0") { 
//     alert( 'Привет' );
// }
// выводит сообщение, так как в условии не пустая строка, а значит true

//2
// let question = prompt('Какое «официальное» название JavaScript?', '');
// if (question == 'ECMAScript') {
//     alert('Верно!');
// } else {
//     alert('Не знаете? ECMAScript!');
// }

//3
// let question = prompt('Inter a number', '');
// if (question > 0) {
//     alert('1');
// } else if (question < 0) {
//     alert('-1');
// } else if (question === 0) {
//     alert('0');
// } else {
//     alert('You need to inter a NUMBER');
// }

//4
// let result = (a + b < 4) ? 'Мало' : 'Много';

//5
// let message = (login == 'Сотрудник') ? 'Привет' :
//     (login == 'Директор') ? 'Здравствуйте' : 
//     (login == '') ? message = 'Нет логина' : 
//     '';


// 11. Логические операторы
// В JavaScript есть три логических оператора: || (ИЛИ), && (И) и ! (НЕ).

// || (ИЛИ)
// Существует всего четыре возможные логические комбинации:
// alert( true || true );   // true
// alert( false || true );  // true
// alert( true || false );  // true
// alert( false || false ); // false
// Если значение не логического типа, то оно к нему приводится в целях вычислений.

// ИЛИ «||» находит первое истинное значение
// result = value1 || value2 || value3;

// Оператор || выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
// Если все операнды являются ложными (false), возвращает последний из них.
// Значение возвращается в исходном виде, без преобразования.

// Другими словами, цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.

// 1. Получение первого истинного значения из списка переменных или выражений.
// let currentUser = null;
// let defaultUser = "John";
// let name = currentUser || defaultUser || "unnamed";
// alert( name ); // выбирается "John" – первое истинное значение
// Если бы и currentUser, и defaultUser были ложными, в качестве результата мы бы наблюдали "unnamed".

// 2. Сокращённое вычисление.
// Операндами могут быть как отдельные значения, так и произвольные выражения. ИЛИ вычисляет их слева направо. 
// Вычисление останавливается при достижении первого истинного значения. 
// Этот процесс называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае, 
// если первого недостаточно для вычисления всего выражения.
// let x;
// true || (x = 1);
// alert(x); // undefined, потому что (x = 1) не вычисляется
// Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:
// let x;
// false || (x = 1);
// alert(x); // 1
// Как мы видим, этот вариант использования || является "аналогом if". 
// Первый операнд преобразуется в логический. Если он оказывается ложным, начинается вычисление второго.

// && (И)
// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:
// alert( true && true );   // true
// alert( false && true );  // false
// alert( true && false );  // false
// alert( false && false ); // false

// И «&&» находит первое ложное значение
// Оператор && выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд преобразует в логическое значение. 
// Если результат false, останавливается и возвращает исходное значение этого операнда.
// Если все операнды были истинными, возвращается последний.

// Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.
// Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.
// Если первый операнд истинный,
// И возвращает второй:
// alert( 1 && 0 ); // 0
// alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
// alert( null && 5 ); // null
// alert( 0 && "no matter what" ); // 0

// Можно передать несколько значений подряд. В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.
// alert( 1 && 2 && null && 3 ); // null
// Когда все значения верны, возвращается последнее
// alert( 1 && 2 && 3 ); // 3
// Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.

// !(НЕ)
// Оператор принимает один аргумент и выполняет следующие действия:

// Сначала приводит аргумент к логическому типу true/false.
// Затем возвращает противоположное значение.

// alert( !true ); // false
// alert( !0 ); // true

// !В частности, двойное НЕ используют для преобразования значений к логическому типу:

// alert( !!"non-empty string" ); // true
// alert( !!null ); // false
// То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, 
// а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.

// Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:
// alert( Boolean("non-empty string") ); // true
// alert( Boolean(null) ); // false

//!Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

//tasks

//1
// alert( null || 2 || undefined ); // 2

//2
// alert( alert(1) || 2 || alert(3) ); // 1 and 2
// Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

// Первый оператор ИЛИ || выполнит первый alert(1).
// Получит undefined и пойдёт дальше, ко второму операнду в поисках истинного значения.
// Так как второй операнд 2 является истинным, то вычисления завершатся, результатом undefined || 2 будет 2, 
// которое будет выведено внешним alert( .... ).
// Второй оператор || не будет выполнен, выполнение до alert(3) не дойдёт, поэтому 3 выведено не будет.

//3
// alert( 1 && null && 2 ); // null

//4
// alert( alert(1) && alert(2) ); // 1, а затем undefined.
// Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.
// Поэтому до правого alertдело не дойдёт, вычисления закончатся на левом.

//5
// alert( null || 2 && 3 || 4 ); // 3
// Приоритет оператора && выше, чем ||, поэтому он выполнится первым.
// Результат 2 && 3 = 3, поэтому выражение приобретает вид:
// null || 3 || 4
// Теперь результатом является первое истинное значение: 3.

//6
// let age = prompt('How old are you?', '');
// if (age >= 14 && age <= 90) {
//     alert('В диапазоне!');
// } else {
//     alert('Не в диапазоне!');
// }

//7
// if (!(age >= 14 && age <= 90))
// if (age < 14 && age > 90)

//8
// if (-1 || 0) alert( 'first' ); // -1 first
// if (-1 && 0) alert( 'second' ); // 0 e.i. false
// if (null || -1 && 1) alert( 'third' ); // 1 third

//9
